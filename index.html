<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Box</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111827;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: ;
            display: block;
            color: white;
        }
        #back-button {
            position: absolute;
            z-index: 200;
            padding: 6px 40px 6px 40px;
            background-color: #7d8fa7;
            border-radius: 6px;
            margin: 10px; /* This will be applied from the top/left */
            color: white;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900">

    <div id="info" class="text-white text-center p-4 text-lg">
        Click an interactive part to zoom in.
    </div>

    <button id="back-button" class="hidden">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-8 h-8">
            <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
        </svg>          
    </button>
    <canvas id="c"></canvas>

    <!-- Import Three.js and OrbitControls -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

    // CORE SETUP
    let scene, camera, renderer, controls;
    let composer, bloomPass; // For post-processing
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const loader = new GLTFLoader();

    // STATE MANAGEMENT
    let isZoomedIn = false;
    let isAnimating = false;
    let hoveredGroupName = null;
    const backButton = document.getElementById('back-button');
    let isDragging = false;       // True when user is dragging fine adj knob
    let previousMouseY = 0;   // Stores last mouse position for drag calculation
    let isLightOn = false;        // Tracks state of power switch
    let microscopeLight;      // Spotlight for microscope
    let currentFocusName = null;

    // CAMERA STATE
    const homeCameraPosition = new THREE.Vector3(0, 4, 4);
    const homeCameraLookAt = new THREE.Vector3(0, 3, 0);
    const targetCameraPosition = new THREE.Vector3();
    const targetCameraLookAt = new THREE.Vector3();

    // MODELS
    const microscopeAssembly = new THREE.Group(); // Main group
    const interactiveModels = {}; // Lookup for models by name
    let clickableMeshes = []; // Array of meshes for raycasting

    // MODEL DATA
    const modelParts = [
        {
            name: 'microscopeBody',
            friendlyName: 'Microscope Body',
            path: 'microscope - body.glb',
            position: new THREE.Vector3(0, 0, 0),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: false
        },
        {
            name: 'fineAdjKnob',
            friendlyName: 'Fine Adjustment Knob',
            path: 'microscope - fine adj knob.glb',
            position: new THREE.Vector3(.73, 1.24, 0.25),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true
        },
        {
            name: 'objLenses',
            friendlyName: 'Objective Lenses',
            path: 'microscope - obj lenses.glb',
            position: new THREE.Vector3(-.9272, 2.749, -0.23),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true,
            rotation: new THREE.Euler(0, 0, 5.93)
        },
        {
            name: 'powerSwitch',
            friendlyName: 'Power Switch',
            path: 'microscope - power switch.glb',
            position: new THREE.Vector3(0.56, .27, 0.75),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true
        },
        {
            name: 'slide',
            friendlyName: 'Slide',
            path: 'microscope - slide.glb',
            position: new THREE.Vector3(-0.65, 1.85, -0.25),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true
        }
    ];

    // INTEREST POINTS
    // Keys here MUST match the 'name' from modelParts list
    const INTEREST_POINTS = {
        ['microscopeBody']: {
            cameraPos: new THREE.Vector3(3, 2, 4), // Closeup position
            lookAt: new THREE.Vector3(1, 2, 0)     // Point to look at
        },
        ['objLenses']: {
            cameraPos: new THREE.Vector3(-2.5, 2.5, 0.5), // Closeup position
            lookAt: new THREE.Vector3(0.8, 1.5, 0)     // Point to look at
        },
        ['powerSwitch']: {
            cameraPos: new THREE.Vector3(0.74, 0.3, 1.7), // Closeup position
            lookAt: new THREE.Vector3(0.6, 0.7, 0)     // Point to look at
        },
        ['slide']: {
            cameraPos: new THREE.Vector3(-1.7, 2.2, 0), // Closeup position
            lookAt: new THREE.Vector3(0.8, 1.5, 0)     // Point to look at
        },
        ['fineAdjKnob']: {
            cameraPos: new THREE.Vector3(0.74, 1.6, 1.7), // Closeup position
            lookAt: new THREE.Vector3(0.6, 1.6, 0)     // Point to look at
        },
    };

    // EMISSIVE CONSTANTS
    const FAINT_GLOW_EMISSIVE = 0x444444; // Emissive color for faint glow
    const HOVER_GLOW_EMISSIVE = 0x888888; // Emissive color for hover glow

    // INITIALIZATION
    init();
    animate();

    function init() {
        // Scene
        scene = new THREE.Scene();
        //scene.background = new THREE.Color(0x111827);
        scene.add(microscopeAssembly); // Add the main group to the scene

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.copy(homeCameraPosition); 
        camera.lookAt(homeCameraLookAt);

        // Renderer
        const canvas = document.querySelector('#c');
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ReinhardToneMapping;

        // Load a 360 HDR image to use for lighting and reflections
        const rgbeLoader = new RGBELoader();
        rgbeLoader.load(
            'hospital_room_4k.hdr', 
            (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                
                // Set it as the scene's background and environment
                //scene.background = texture;
                scene.environment = texture;
                
                console.log("Environment map loaded.");

                // --- MOVED MODEL LOADING HERE ---
                // Now we load models *only after* the environment is ready.
                modelParts.forEach(partInfo => {
                    loadModel(partInfo);
                });
                
                // --- MOVED PLANE CREATION HERE ---
                // The plane's material will also benefit from reflections.
                const planeGeometry = new THREE.PlaneGeometry(20, 20);
                const planeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4B5563,
                    roughness: 0.8, 
                    metalness: 0.2
                });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = -Math.PI / 2;
                plane.receiveShadow = true;
                scene.add(plane);
            },
            undefined,
            (error) => {
                console.error('An error occurred loading the environment map', error);
            }
        );

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        //controls.maxPolarAngle = (Math.PI / 2) - 0.05;
        controls.enablePan = false;
        controls.target.copy(homeCameraLookAt);
        
        // LIGHTING
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.normalBias = 0.02;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -25;
        directionalLight.shadow.camera.right = 25;
        directionalLight.shadow.camera.top = 25;
        directionalLight.shadow.camera.bottom = -25;
        directionalLight.shadow.bias = -0.0001; 
        directionalLight.shadow.normalBias = 0.02;
        scene.add(directionalLight);

        // This light is toggled by power switch
        microscopeLight = new THREE.SpotLight(0xffffff, 50, 10, Math.PI * 0.15, 0.5);
        // Position at slide and point up at lens
        microscopeLight.position.set(-0.65, 0.6, -0.25);
        microscopeLight.target.position.set(-0.65, 2.5, -0.25);
        //microscopeLight.visible = false;
        scene.add(microscopeLight);
        scene.add(microscopeLight.target);
        
        // POST-PROCESSING (GLOW EFFECT)
        const renderPass = new RenderPass(scene, camera);

        bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0, // strength
            0, // radius
            0  // threshold (glows anything brighter than 0.1)
        );

        const outputPass = new OutputPass();

        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);
        composer.addPass(outputPass);

        // EVENT LISTENERS
        window.addEventListener('resize', onWindowResize);
        backButton.addEventListener('click', zoomOut);
        canvas.addEventListener('click', onMouseClick); 
        canvas.addEventListener('mousemove', onMouseMove); 
        canvas.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onDragMove);
        window.addEventListener('mouseup', onMouseUp);
    }

    // LOAD MODEL FUNCTION
    function loadModel(partInfo) {
        loader.load(
            partInfo.path,
            (gltf) => {
                const model = gltf.scene;
                
                // Set properties
                model.position.copy(partInfo.position);
                model.scale.copy(partInfo.scale);
                model.name = partInfo.name;

                // Apply initial rotation if defined
                if (partInfo.rotation) {
                    model.rotation.copy(partInfo.rotation);
                }

                // Add to master group and store ref in lookup
                microscopeAssembly.add(model);
                interactiveModels[partInfo.name] = model;

                // Find meshes for clicking and shadows
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = true;
                        
                        if (partInfo.isInteractive) {
                            clickableMeshes.push(child);
                            child.userData.interactiveName = partInfo.name;
                            
                            const processMaterial = (mat) => {
                                // (metalness, roughness, maps, etc.)
                                const newMat = mat.clone();
                                
                                // Store original emissive value
                                // Ensure userData exists
                                if (!newMat.userData) newMat.userData = {}; 
                                newMat.userData.originalEmissive = newMat.emissive.clone();
                                
                                // Set the faint glow
                                newMat.emissive.setHex(FAINT_GLOW_EMISSIVE);
                                return newMat;
                            };

                            if (Array.isArray(child.material)) {
                                // Mesh has multiple materials
                                child.material = child.material.map(processMaterial);
                            } else if (child.material) {
                                // Mesh has one material
                                child.material = processMaterial(child.material);
                            }
                        }
                    }
                });
                console.log(`Loaded and positioned: ${partInfo.name}`);
            },
            undefined,
            (error) => {
                console.error(`Error loading ${partInfo.name}:`, error);
            }
        );
    }


    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    // HOVER LOGIC
    function onMouseMove(event) {
        if (currentFocusName || isAnimating || isDragging) {
            if (hoveredGroupName) {
                setGroupEmissive(hoveredGroupName, FAINT_GLOW_EMISSIVE);
                hoveredGroupName = null;
            }
            return;
        }

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(clickableMeshes);

        let newHoveredGroupName = null;
        if (intersects.length > 0) {
            newHoveredGroupName = intersects[0].object.userData.interactiveName;
        }

        if (newHoveredGroupName !== hoveredGroupName) {
            if (hoveredGroupName) {
                setGroupEmissive(hoveredGroupName, FAINT_GLOW_EMISSIVE);
            }
            hoveredGroupName = newHoveredGroupName;
            if (hoveredGroupName) {
                setGroupEmissive(hoveredGroupName, HOVER_GLOW_EMISSIVE);
            }
        }
    }

    // HELPER FUNCTION for setting group glow
    function setGroupEmissive(modelName, emissiveValue) {
        const model = interactiveModels[modelName];
        if (!model) return;

        model.traverse((child) => {
            if (child.isMesh && child.userData.interactiveName === modelName) {
                const setEmissive = (mat) => {
                    if (!mat.userData || !mat.userData.originalEmissive) {
                        // This material wasn't processed (e.g., non-interactive part of group)
                        // Or it's a part of the group we shouldn't be glowing
                        return; 
                    }

                    if (emissiveValue !== null) {
                        mat.emissive.setHex(emissiveValue);
                    } else {
                        // Reset to original (null) by copying stored value
                        mat.emissive.copy(mat.userData.originalEmissive);
                    }
                };

                if (Array.isArray(child.material)) {
                    child.material.forEach(setEmissive);
                } else if (child.material) {
                    setEmissive(child.material);
                }
            }
        });
    }

    function onMouseClick(event) {
        if (isAnimating || isDragging) return;

        // Handle clicks while zoomed in
        if (currentFocusName) {
            if (currentFocusName === 'powerSwitch') {
                // Check if click was on the power switch
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(clickableMeshes);
                if (intersects.length > 0 && intersects[0].object.userData.interactiveName === 'powerSwitch') {
                    isLightOn = !isLightOn;
                    microscopeLight.visible = isLightOn;
                    
                    // Power Switch rotation
                    const switchModel = interactiveModels['powerSwitch'];
                    if (switchModel) {
                        const targetRotationY = isLightOn ? 0.26 : 0; 
                        switchModel.rotation.y = targetRotationY;
                    }
                }
            }
            return;
        }

        // Handle clicks while zoomed out
        if (hoveredGroupName) {
            zoomIn(hoveredGroupName);
            return;
        }
        
        // Fallback: check raycaster just in case (for touch screens, etc.)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(clickableMeshes);
        if (intersects.length > 0) {
            const modelName = intersects[0].object.userData.interactiveName;
            if (modelName) zoomIn(modelName);
        }
    }

    function onMouseDown(event) {
        // Only start dragging if zoomed in on knob
        if (isAnimating || currentFocusName !== 'fineAdjKnob') return;

        // Check if the click was on knob
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        const knobModel = interactiveModels['fineAdjKnob'];
        if (!knobModel) return;

        const intersects = raycaster.intersectObject(knobModel, true);

        if (intersects.length > 0) {
            isDragging = true;
            previousMouseY = event.clientY;
            document.body.style.cursor = 'ns-resize'; // Vertical resize cursor
        }
    }

    function onDragMove(event) {
        if (!isDragging) return;

        const deltaY = event.clientY - previousMouseY;
        const rotationSpeed = 0.01; // Knob sensitivity

        const knobModel = interactiveModels['fineAdjKnob'];
        if (knobModel) {
            // Rotate knob around z-axis
            knobModel.rotation.z += deltaY * rotationSpeed;
        }
        previousMouseY = event.clientY;
    }

    function onMouseUp(event) {
        isDragging = false;
        document.body.style.cursor = 'default';
    }

    function zoomIn(modelName) {
        const modelData = INTEREST_POINTS[modelName];
        const partData = modelParts.find(p => p.name === modelName);
        if (!modelData || !partData) return;

        currentFocusName = modelName; // Set current focus
        isAnimating = true;
        targetCameraPosition.copy(modelData.cameraPos);
        targetCameraLookAt.copy(modelData.lookAt);
        controls.enabled = false;
        backButton.classList.remove('hidden');
        document.getElementById('info').innerText = `Now viewing: ${partData.friendlyName || modelName}`;

        // Stop all glow effects
        if (hoveredGroupName) {
            setGroupEmissive(hoveredGroupName, null); // null resets to original
            hoveredGroupName = null;
        }
        modelParts.forEach(part => {
            if (part.isInteractive) setGroupEmissive(part.name, null);
        });
        
        // Set glow for *only* the focused object
        // --- UPDATED: Removed special case for green glow ---
        setGroupEmissive(currentFocusName, HOVER_GLOW_EMISSIVE);
    }

    function zoomOut() {
        currentFocusName = null; // Clear focus
        isAnimating = true;
        isDragging = false;
        targetCameraPosition.copy(homeCameraPosition);
        targetCameraLookAt.copy(homeCameraLookAt);
        controls.enabled = true;
        backButton.classList.add('hidden');
        document.getElementById('info').innerText = 'Click an interactive part to zoom in.';
        document.body.style.cursor = 'default';

        // Re-enable faint glow for all interactive models
        modelParts.forEach(part => {
            if (part.isInteractive) {
                setGroupEmissive(part.name, FAINT_GLOW_EMISSIVE);
            }
        });

        // Turn off microscope light if it was on
        isLightOn = false;
        microscopeLight.visible = false;

        // --- NEW: Reset switch rotation on zoom out ---
        const switchModel = interactiveModels['powerSwitch'];
        if (switchModel) {
            switchModel.rotation.z = 0; // Reset to "off" position
        }
    }

    // ANIMATION LOOP
    function animate() {
        requestAnimationFrame(animate);
        
        // Damping value - adjust to speed up movements
        const delta = 0.05;

        if (isAnimating) {
            camera.position.lerp(targetCameraPosition, delta);
            controls.target.lerp(targetCameraLookAt, delta);

            const distance = camera.position.distanceTo(targetCameraPosition);
            if (distance < 0.01) {
                camera.position.copy(targetCameraPosition);
                controls.target.copy(targetCameraLookAt);
                isAnimating = false;
            }
        }

        // if (interactiveModels.fineKnob) {
        //     interactiveModels.fineKnob.rotation.y += 0.01;
        // }

        controls.update(); 
        composer.render();
    }
    </script>
</body>
</html>