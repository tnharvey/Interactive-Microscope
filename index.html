<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Box</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111827;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: ;
            display: block;
            color: white;
        }
        #back-button {
            position: absolute;
            z-index: 200;
            padding: 6px 40px 6px 40px;
            background-color: #7d8fa7;
            border-radius: 6px;
            margin: 10px; /* This will be applied from the top/left */
            color: white;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900">

    <div id="info" class="text-white text-center p-4 text-lg">
        Click an interactive part to zoom in.
    </div>

    <button id="back-button" class="hidden">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-8 h-8">
            <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
        </svg>          
    </button>
    <canvas id="c"></canvas>

    <!-- Import Three.js and OrbitControls -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

    // CORE SETUP
    let scene, camera, renderer, controls;
    let composer, bloomPass; // For post-processing
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const loader = new GLTFLoader();

    // STATE MANAGEMENT
    let isZoomedIn = false;
    let isAnimating = false;
    let hoveredGroupName = null;
    const backButton = document.getElementById('back-button');

    // CAMERA STATE
    const homeCameraPosition = new THREE.Vector3(0, 4, 4);
    const homeCameraLookAt = new THREE.Vector3(0, 3, 0);
    const targetCameraPosition = new THREE.Vector3();
    const targetCameraLookAt = new THREE.Vector3();

    // MODELS
    const microscopeAssembly = new THREE.Group(); // Main group
    const interactiveModels = {}; // Lookup for models by name
    let clickableMeshes = []; // Array of meshes for raycasting

    // MODEL DATA
    const modelParts = [
        {
            name: 'microscopeBody',
            friendlyName: 'Microscope Body',
            path: 'microscope - body.glb',
            position: new THREE.Vector3(0, 0, 0),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true
        },
        {
            name: 'fineAdjKnob',
            friendlyName: 'Fine Adjustment Knob',
            path: 'microscope - fine adj knob.glb',
            position: new THREE.Vector3(.73, 1.24, 0.25),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true
        },
        {
            name: 'objLenses',
            friendlyName: 'Objective Lenses',
            path: 'microscope - obj lenses.glb',
            position: new THREE.Vector3(-.9272, 2.749, -0.23),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true,
            rotation: new THREE.Euler(0, 0, 5.93)
        },
        {
            name: 'powerSwitch',
            friendlyName: 'Power Switch',
            path: 'microscope - power switch.glb',
            position: new THREE.Vector3(0.56, .27, 0.75),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true
        },
        {
            name: 'slide',
            friendlyName: 'Slide',
            path: 'microscope - slide.glb',
            position: new THREE.Vector3(-0.65, 1.85, -0.25),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true
        }
    ];

    // INTEREST POINTS
    // Keys here MUST match the 'name' from modelParts list
    const INTEREST_POINTS = {
        ['microscopeBody']: {
            cameraPos: new THREE.Vector3(3, 2, 4), // Closeup position
            lookAt: new THREE.Vector3(1, 2, 0)     // Point to look at
        },
        ['objLenses']: {
            cameraPos: new THREE.Vector3(-2.5, 2.5, 0.5), // Closeup position
            lookAt: new THREE.Vector3(0.8, 1.5, 0)     // Point to look at
        },
        ['powerSwitch']: {
            cameraPos: new THREE.Vector3(0.74, 1, 1.7), // Closeup position
            lookAt: new THREE.Vector3(0.6, .3, 0)     // Point to look at
        },
        ['slide']: {
            cameraPos: new THREE.Vector3(-1.7, 2.2, 0), // Closeup position
            lookAt: new THREE.Vector3(0.8, 1.5, 0)     // Point to look at
        },
        ['fineAdjKnob']: {
            cameraPos: new THREE.Vector3(0.74, 1.6, 1.7), // Closeup position
            lookAt: new THREE.Vector3(0.6, 1.6, 0)     // Point to look at
        },
    };

    // EMISSIVE CONSTANTS
    const FAINT_GLOW_EMISSIVE = 0x222222; // Emissive color for faint glow
    const HOVER_GLOW_EMISSIVE = 0x888888; // Emissive color for hover glow

    // INITIALIZATION
    init();
    animate();

    function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111827);
        scene.add(microscopeAssembly); // Add the master group to the scene

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.copy(homeCameraPosition); 
        camera.lookAt(homeCameraLookAt);

        // Renderer
        const canvas = document.querySelector('#c');
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.toneMapping = THREE.ReinhardToneMapping;

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.copy(homeCameraLookAt);
        
        // LIGHTING
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // MODEL LOADING LOOP
        // Loop through model data and load each part
        modelParts.forEach(partInfo => {
            loadModel(partInfo);
        });
        
        // Add ground plane
        const planeGeometry = new THREE.PlaneGeometry(20, 20);
        const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x4B5563 });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // POST-PROCESSING (GLOW EFFECT)
        const renderPass = new RenderPass(scene, camera);

        bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0, // strength
            0, // radius
            0  // threshold (glows anything brighter than 0.1)
        );

        const outputPass = new OutputPass();

        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(bloomPass);
        composer.addPass(outputPass);

        // EVENT LISTENERS
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('click', onMouseClick);
        window.addEventListener('mousemove', onMouseMove);
        backButton.addEventListener('click', zoomOut);
    }

    // LOAD MODEL FUNCTION
    function loadModel(partInfo) {
        loader.load(
            partInfo.path,
            (gltf) => {
                const model = gltf.scene;
                
                // Set properties
                model.position.copy(partInfo.position);
                model.scale.copy(partInfo.scale);
                model.name = partInfo.name;

                // Apply initial rotation if defined
                if (partInfo.rotation) {
                    model.rotation.copy(partInfo.rotation);
                }

                // Add to master group and store ref in lookup
                microscopeAssembly.add(model);
                interactiveModels[partInfo.name] = model;

                // Find meshes for clicking and shadows
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        if (partInfo.isInteractive) {
                            clickableMeshes.push(child);
                            child.userData.interactiveName = partInfo.name;
                            // Store original material and add faint glow
                            child.material = child.material.clone(); 
                            child.userData.originalEmissive = child.material.emissive.clone();
                            child.material.emissive.setHex(FAINT_GLOW_EMISSIVE);
                        }
                    }
                });
                console.log(`Loaded and positioned: ${partInfo.name}`);
            },
            undefined,
            (error) => {
                console.error(`Error loading ${partInfo.name}:`, error);
            }
        );
    }


    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    // HOVER LOGIC
    function onMouseMove(event) {
        // No hovering if zoomed in or moving
        if (isZoomedIn || isAnimating) {
            // If hovered group, reset it
            if (hoveredGroupName) {
                setGroupEmissive(hoveredGroupName, FAINT_GLOW_EMISSIVE);
                hoveredGroupName = null;
            }
            return;
        }

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(clickableMeshes);

        let newHoveredGroupName = null;
        if (intersects.length > 0) {
            // Get group name from hit mesh
            newHoveredGroupName = intersects[0].object.userData.interactiveName;
        }

        // Check if hovered group changed
        if (newHoveredGroupName !== hoveredGroupName) {
            // Reset old group (if it exists)
            if (hoveredGroupName) {
                setGroupEmissive(hoveredGroupName, FAINT_GLOW_EMISSIVE);
            }
            
            // Set new group
            hoveredGroupName = newHoveredGroupName;
            
            // Highlight new group (if it exists)
            if (hoveredGroupName) {
                setGroupEmissive(hoveredGroupName, HOVER_GLOW_EMISSIVE);
            }
        }
    }

    // HELPER FUNCTION for setting group glow
    function setGroupEmissive(modelName, emissiveValue) {
        const model = interactiveModels[modelName];
        if (!model) return;

        model.traverse((child) => {
            if (child.isMesh && child.userData.interactiveName === modelName) {
                if (emissiveValue !== null) {
                    child.material.emissive.setHex(emissiveValue);
                } else {
                    // Reset to original (null) by copying stored value
                    child.material.emissive.copy(child.userData.originalEmissive);
                }
            }
        });
    }

    function onMouseClick(event) {
        if (isZoomedIn || isAnimating) return;

        if (hoveredGroupName) {
            zoomIn(hoveredGroupName);
            return;
        }

        // Fallback raycast if not hovering (e.g., fast click)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        // Check for intersects with 'clickableMeshes' array
        const intersects = raycaster.intersectObjects(clickableMeshes);

        if (intersects.length > 0) {
            const modelName = intersects[0].object.userData.interactiveName;
            if (modelName) {
                zoomIn(modelName);
            }
        }
    }

    // ZOOM FUNCTIONS
    function zoomIn(modelName) {
        const pointData = INTEREST_POINTS[modelName];
        const modelData = modelParts.find(p => p.name === modelName);

        if (!pointData || !modelData) {
            console.error("No data for model:", modelName);
            return;
        }

        isZoomedIn = true;
        isAnimating = true;
        targetCameraPosition.copy(pointData.cameraPos);
        targetCameraLookAt.copy(pointData.lookAt);
        controls.enabled = false;
        backButton.classList.remove('hidden');
        
        document.getElementById('info').innerText = `Now viewing: ${modelData.friendlyName}`;

        // Stop all glows when zoomed in
        if (hoveredGroupName) {
            setGroupEmissive(hoveredGroupName, null); // null resets to original
            hoveredGroupName = null;
        }
        // Turn off faint glow for all meshes
        clickableMeshes.forEach(mesh => {
            mesh.material.emissive.copy(mesh.userData.originalEmissive);
        });
    }

    function zoomOut() {
        isZoomedIn = false;
        isAnimating = true;
        targetCameraPosition.copy(homeCameraPosition);
        targetCameraLookAt.copy(homeCameraLookAt);
        controls.enabled = true;
        backButton.classList.add('hidden');
        document.getElementById('info').innerText = 'Click an interactive part to zoom in.';

        // Re-enable faint glow for all meshes
        clickableMeshes.forEach(mesh => {
            mesh.material.emissive.setHex(FAINT_GLOW_EMISSIVE);
        });
    }

    // ANIMATION LOOP
    function animate() {
        requestAnimationFrame(animate);
        
        // Damping value - adjust to speed up movements
        const delta = 0.1;

        if (isAnimating) {
            camera.position.lerp(targetCameraPosition, delta);
            controls.target.lerp(targetCameraLookAt, delta);

            const distance = camera.position.distanceTo(targetCameraPosition);
            if (distance < 0.01) {
                camera.position.copy(targetCameraPosition);
                controls.target.copy(targetCameraLookAt);
                isAnimating = false;
            }
        }

        // if (interactiveModels.fineKnob) {
        //     interactiveModels.fineKnob.rotation.y += 0.01;
        // }

        controls.update(); 
        composer.render();
    }
    </script>
</body>
</html>