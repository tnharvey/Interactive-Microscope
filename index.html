<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Box</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #111827;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: ;
            display: block;
            color: white;
        }
        #back-button {
            position: absolute;
            z-index: 200;
            padding: 6px 40px 6px 40px;
            background-color: #7d8fa7;
            border-radius: 6px;
            margin: 10px; /* This will be applied from the top/left */
            color: white;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-900">

    <div id="info" class="text-white text-center p-4 text-lg">
        Click an interactive part to zoom in.
    </div>

    <button id="back-button" class="hidden">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-8 h-8">
            <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
        </svg>          
    </button>
    <canvas id="c"></canvas>

    <!-- Import Three.js and OrbitControls -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "three/addons/postprocessing/EffectComposer.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js",
                "three/addons/postprocessing/RenderPass.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js",
                "three/addons/postprocessing/OutlinePass.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/OutlinePass.js",
                "three/addons/postprocessing/OutputPass.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/OutputPass.js",
                "three/addons/loaders/RGBELoader.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/RGBELoader.js"
            }
        }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js'; 
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import Stats from 'three/addons/libs/stats.module.js'

    // CORE SETUP
    let scene, camera, renderer, controls, composer, outlinePass; // For post-processing
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const loader = new GLTFLoader();

    // STATE MANAGEMENT
    let isZoomedIn = false;
    let isAnimating = false;
    const backButton = document.getElementById('back-button');
    let currentFocusName = null;

    // INTERACTION STATES
    let isDragging = false;       // True when user is dragging fine adj knob
    let previousMouseY = 0;   // Stores last mouse position for drag calculation
    let isLightOn = false;        // Tracks power switch
    let microscopeLight;      // Spotlight for microscope
    let isSnapping = false; // Track snapping animation

    // LENS ROTATION STATE
    let currentLensAngle = 0; // Total rotation angle around local Y-axis
    let targetLensAngle = 0; // Angle to snap to
    let initialLensQuaternion = new THREE.Quaternion(); // Store original tilt

    // CUSTOM LENS SNAP POINTS (RADIANS)
    const TARGET_LENS_ANGLES = [
        0,                                  // Initial position (0 degrees)
        THREE.MathUtils.degToRad(140),       // Example stop point 1
        THREE.MathUtils.degToRad(230)      // Example stop point 2
    ];

    // CAMERA STATE
    const homeCameraPosition = new THREE.Vector3(0, 4, 4);
    const homeCameraLookAt = new THREE.Vector3(0, 3, 0);
    const targetCameraPosition = new THREE.Vector3();
    const targetCameraLookAt = new THREE.Vector3();

    // MODELS
    const microscopeAssembly = new THREE.Group(); // Main group
    const interactiveModels = {}; // Lookup for models by name
    let clickableMeshes = []; // Array of meshes for raycasting
    let allInteractiveMeshes = [];
    
    // OBJECTIVE LENSES AXIS
    const localLensRotationAxis = new THREE.Vector3(0, 1, 0);

    // MODEL DATA
    const modelParts = [
        {
            name: 'microscopeBody',
            friendlyName: 'Microscope Body',
            path: 'microscope - body.glb',
            position: new THREE.Vector3(0, 0, 0),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: false
        },
        {
            name: 'fineAdjKnob',
            friendlyName: 'Fine Adjustment Knob',
            path: 'microscope - fine adj knob.glb',
            position: new THREE.Vector3(.73, 1.24, 0.25),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true
        },
        {
            name: 'objLenses',
            friendlyName: 'Objective Lenses',
            path: 'microscope - obj lenses.glb',
            position: new THREE.Vector3(-.9272, 2.749, -0.23),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true,
            rotation: new THREE.Euler(0, 0, 5.93)
        },
        {
            name: 'powerSwitch',
            friendlyName: 'Power Switch',
            path: 'microscope - power switch.glb',
            position: new THREE.Vector3(0.56, .27, 0.75),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true
        },
        {
            name: 'slide',
            friendlyName: 'Slide',
            path: 'microscope - slide.glb',
            position: new THREE.Vector3(-0.65, 1.85, -0.25),
            scale: new THREE.Vector3(1, 1, 1),
            isInteractive: true
        }
    ];

    // INTEREST POINTS
    // Keys here MUST match the 'name' from modelParts list
    const INTEREST_POINTS = {
        ['microscopeBody']: {
            cameraPos: new THREE.Vector3(3, 2, 4), // Closeup position
            lookAt: new THREE.Vector3(1, 2, 0)     // Point to look at
        },
        ['objLenses']: {
            cameraPos: new THREE.Vector3(-2.5, 2.5, 0.5), // Closeup position
            lookAt: new THREE.Vector3(0.8, 1.5, 0)     // Point to look at
        },
        ['powerSwitch']: {
            cameraPos: new THREE.Vector3(0.74, 0.3, 1.7), // Closeup position
            lookAt: new THREE.Vector3(0.6, 0.7, 0)     // Point to look at
        },
        ['slide']: {
            cameraPos: new THREE.Vector3(-1.7, 2.2, 0), // Closeup position
            lookAt: new THREE.Vector3(0.8, 1.5, 0)     // Point to look at
        },
        ['fineAdjKnob']: {
            cameraPos: new THREE.Vector3(0.74, 1.6, 1.7), // Closeup position
            lookAt: new THREE.Vector3(0.6, 1.6, 0)     // Point to look at
        },
    };

    // EMISSIVE CONSTANTS
    const FAINT_GLOW_EMISSIVE = 0x444444; // Emissive color for faint glow
    const HOVER_GLOW_EMISSIVE = 0x888888; // Emissive color for hover glow
    let hoveredGroupName = null;

    // STATS
    const stats = new Stats();
    document.body.appendChild(stats.dom);

    // INITIALIZATION
    init();
    animate();

    function init() {
        // Scene
        scene = new THREE.Scene();
        //scene.background = new THREE.Color(0x111827);
        scene.add(microscopeAssembly); // Add the main group to the scene

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.copy(homeCameraPosition); 
        camera.lookAt(homeCameraLookAt);

        // Renderer
        const canvas = document.querySelector('#c');
        renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ReinhardToneMapping;

        // Load a 360 HDR image to use for lighting and reflections
        const rgbeLoader = new RGBELoader();
        rgbeLoader.load(
            'hospital_room_4k.hdr', 
            (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                
                // Set it as the scene's background and environment
                //scene.background = texture;
                scene.environment = texture;
                
                console.log("Environment map loaded.");

                // --- MOVED MODEL LOADING HERE ---
                // Now we load models *only after* the environment is ready.
                modelParts.forEach(partInfo => {
                    loadModel(partInfo);
                });
                
                // --- MOVED PLANE CREATION HERE ---
                // The plane's material will also benefit from reflections.
                const planeGeometry = new THREE.PlaneGeometry(20, 20);
                const planeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4B5563,
                    roughness: 0.8, 
                    metalness: 0.2
                });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = -Math.PI / 2;
                plane.receiveShadow = true;
                scene.add(plane);

                // Initial Outline Setup - Select all interactive parts
                setInitialOutline();
            },
            undefined,
            (error) => {
                console.error('An error occurred loading the environment map', error);
            }
        );

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        //controls.maxPolarAngle = (Math.PI / 2) - 0.05;
        controls.enablePan = false;
        controls.target.copy(homeCameraLookAt);
        
        // LIGHTING
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        directionalLight.shadow.normalBias = 0.02;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -25;
        directionalLight.shadow.camera.right = 25;
        directionalLight.shadow.camera.top = 25;
        directionalLight.shadow.camera.bottom = -25;
        directionalLight.shadow.bias = -0.0001; 
        directionalLight.shadow.normalBias = 0.02;
        scene.add(directionalLight);

        // This light is toggled by power switch
        microscopeLight = new THREE.SpotLight(0xffffff, 50, 10, Math.PI * 0.15, 0.5);
        // Position at slide and point up at lens
        microscopeLight.position.set(-0.65, 0.6, -0.25);
        microscopeLight.target.position.set(-0.65, 2.5, -0.25);
        microscopeLight.visible = false;
        scene.add(microscopeLight);
        scene.add(microscopeLight.target);
        
        // POST-PROCESSING (GLOW EFFECT)
        const renderPass = new RenderPass(scene, camera);

        // Create OutlinePass
        const resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
        outlinePass = new OutlinePass(resolution, scene, camera);
        
        // Configure look of outline (adjust values to tune look)
        outlinePass.edgeStrength = 4.0;
        outlinePass.edgeThickness = 0.01;
        outlinePass.edgeGlow = 0.0; // Sharp outline, no glow
        outlinePass.visibleEdgeColor.set(0xffff00); // Bright Yellow/Gold for hover
        outlinePass.hiddenEdgeColor.set(0x000000); // Black behind objects
        
        // Add passes to composer
        const outputPass = new OutputPass();
        composer = new EffectComposer(renderer);
        composer.addPass(renderPass);
        composer.addPass(outlinePass); // Add OutlinePass
        composer.addPass(outputPass);

        // EVENT LISTENERS
        window.addEventListener('resize', onWindowResize);
        backButton.addEventListener('click', zoomOut);
        canvas.addEventListener('click', onMouseClick);
        canvas.addEventListener('mousemove', onMouseMove); 
        canvas.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onDragMove);
        window.addEventListener('mouseup', onMouseUp);
        
        // LISTENERS FOR TOUCH DRAGGING
        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        window.addEventListener('touchmove', onTouchMove, { passive: false });
        window.addEventListener('touchend', onTouchEnd);
    }

    // LOAD MODEL FUNCTION
    function loadModel(partInfo) {
        loader.load(
            partInfo.path,
            (gltf) => {
                const model = gltf.scene;
                
                // Set properties
                model.position.copy(partInfo.position);
                model.scale.copy(partInfo.scale);
                model.name = partInfo.name;

                // Apply initial rotation if defined
                if (partInfo.rotation) {
                    model.rotation.copy(partInfo.rotation);
                }

                // Add to master group and store ref in lookup
                microscopeAssembly.add(model);
                interactiveModels[partInfo.name] = model;

                if (partInfo.name === 'objLenses') {
                    initialLensQuaternion.copy(model.quaternion); // Store initial tilt as Quaternion for objLenses
                }

                // Find meshes for clicking and shadows
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = false;
                        child.receiveShadow = true;
                        
                        if (partInfo.isInteractive) {
                            clickableMeshes.push(child);
                            child.userData.interactiveName = partInfo.name;
                            // Collect all meshes for interactive parts
                            allInteractiveMeshes.push(child); 
                        }
                        
                        if (Array.isArray(child.material)) {
                            child.material = child.material.map(mat => mat.clone());
                        } else if (child.material) {
                            child.material = child.material.clone();
                        }
                        // Ensure base materials are NOT emissive
                        if (child.material && child.material.emissive) {
                            child.material.emissive.setHex(0x000000);
                        }
                    }
                });
                console.log(`Loaded and positioned: ${partInfo.name}`);
            },
            undefined,
            (error) => {
                console.error(`Error loading ${partInfo.name}:`, error);
            }
        );
    }

    // INITIAL OUTLINE SETUP
    function setInitialOutline() {
        // Set all interactive parts to be faintly outlined initially
        outlinePass.edgeStrength = 1.0;
        outlinePass.visibleEdgeColor.set(0x444444);
        outlinePass.selectedObjects = allInteractiveMeshes;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        outlinePass.resolution.set(window.innerWidth, window.innerHeight);
    }

    // HOVER LOGIC
    function onMouseMove(event) {
        // If zoomed in or dragging, skip hover effects
        if (currentFocusName || isAnimating || isDragging) return;

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(clickableMeshes);

        let newHoveredGroupName = null;
        if (intersects.length > 0) {
            newHoveredGroupName = intersects[0].object.userData.interactiveName;
        }
        
        // Outline Hover Logic
        if (newHoveredGroupName !== hoveredGroupName) {
            hoveredGroupName = newHoveredGroupName;
            
            // Always reset to initial state
            outlinePass.selectedObjects = allInteractiveMeshes.slice();
            outlinePass.edgeStrength = 1.0;
            outlinePass.visibleEdgeColor.set(0x444444);

            if (hoveredGroupName) {
                // Find meshes corresponding to hovered group
                const meshesToHighlight = allInteractiveMeshes.filter(mesh => 
                    mesh.userData.interactiveName === hoveredGroupName
                );

                // Set high-strength, bright yellow outline for hovered group
                outlinePass.edgeStrength = 5.0;
                outlinePass.visibleEdgeColor.set(0xffff00); // Bright Yellow/Gold
                outlinePass.selectedObjects = meshesToHighlight;
            }
        }
    }

    function onMouseClick(event) {
        if (isAnimating || isDragging) return;

        // Handle clicks while zoomed in
        if (currentFocusName) {
            if (currentFocusName === 'powerSwitch') {
                // Check if click was on the power switch
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(clickableMeshes);
                if (intersects.length > 0 && intersects[0].object.userData.interactiveName === 'powerSwitch') {
                    isLightOn = !isLightOn;
                    microscopeLight.visible = isLightOn;
                    
                    // Power Switch rotation
                    const switchModel = interactiveModels['powerSwitch'];
                    if (switchModel) {
                        const targetRotationY = isLightOn ? 0.26 : 0; 
                        switchModel.rotation.y = targetRotationY;
                    }
                }
            }
            return;
        }

        // Handle clicks while zoomed out
        if (hoveredGroupName) {
            zoomIn(hoveredGroupName);
            return;
        }
        
        // Fallback: check raycaster just in case (for touch screens, etc.)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(clickableMeshes);
        if (intersects.length > 0) {
            const modelName = intersects[0].object.userData.interactiveName;
            if (modelName) zoomIn(modelName);
        }
    }

    function onMouseDown(event) {
        // Only start dragging if zoomed in on knob
        if (isAnimating || (currentFocusName !== 'fineAdjKnob' && currentFocusName !== 'objLenses')) return;

        // Check if the click was on knob
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        // Check intersection with either knob OR lenses
        let interactiveModel;
        if (currentFocusName === 'fineAdjKnob') {
            interactiveModel = interactiveModels['fineAdjKnob'];
        } else if (currentFocusName === 'objLenses') {
            interactiveModel = interactiveModels['objLenses'];
        }
        
        if (!interactiveModel) return;
        const intersects = raycaster.intersectObject(interactiveModel, true);

        if (intersects.length > 0) {
            isDragging = true;
            previousMouseY = event.clientY;
            document.body.style.cursor = 'ns-resize'; // Horizontal resize cursor
        }
    }

    function onDragMove(event) {
        if (!isDragging) return;

        const deltaY = event.clientY - previousMouseY;
        const rotationSpeed = 0.01; // Knob sensitivity
        const angle = deltaY * rotationSpeed;

        let modelToRotate = interactiveModels[currentFocusName];
        
        if (modelToRotate) {
            if (currentFocusName === 'fineAdjKnob') {
                modelToRotate.rotation.z += deltaY * rotationSpeed;
            } else if (currentFocusName === 'objLenses') {
                // Track total angle and apply rotation via quaternion
                currentLensAngle += angle;
                const spinQuaternion = new THREE.Quaternion().setFromAxisAngle(localLensRotationAxis, currentLensAngle);
                // Combine the initial tilt with the interactive spin
                modelToRotate.quaternion.multiplyQuaternions(initialLensQuaternion, spinQuaternion);
                
                console.log('Current Lens Angle (Radians):', currentLensAngle.toFixed(4));
            }
        }
        previousMouseY = event.clientY;
    }

    function onMouseUp(event) {
        if (isDragging) {
            if (currentFocusName === 'objLenses') {
                snapToNearestObjective();
            }
        }
        isDragging = false;
        document.body.style.cursor = 'default';
    }

    // DRAG HANDLERS for TOUCH
    function onTouchStart(event) {
        // Only allow drag if zoomed in on knob
        if (isAnimating || (currentFocusName !== 'fineAdjKnob' && currentFocusName !== 'objLenses')) return;

        const touch = event.touches[0];
        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (touch.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        let interactiveModel;
        if (currentFocusName === 'fineAdjKnob') {
            interactiveModel = interactiveModels['fineAdjKnob'];
        } else if (currentFocusName === 'objLenses') {
            interactiveModel = interactiveModels['objLenses'];
        }

        if (!interactiveModel) return;
        const intersects = raycaster.intersectObject(interactiveModel, true);

        if (intersects.length > 0) {
            isDragging = true;
            previousMouseY = touch.clientY;
            event.preventDefault();
        }
    }

    function onTouchMove(event) {
        if (!isDragging) return;
        
        // Stop screen from scrolling while rotating knob
        event.preventDefault();

        const touch = event.touches[0];
        const deltaY = touch.clientY - previousMouseY;
        const rotationSpeed = 0.01;
        const angle = deltaY * rotationSpeed;

        let modelToRotate = interactiveModels[currentFocusName];
        
        if (modelToRotate) {
            if (currentFocusName === 'fineAdjKnob') {
                modelToRotate.rotation.z += deltaY * rotationSpeed;
            } else if (currentFocusName === 'objLenses') {
                currentLensAngle += angle;
                const spinQuaternion = new THREE.Quaternion().setFromAxisAngle(localLensRotationAxis, currentLensAngle);
                
                // Combine initial tilt with interactive spin
                modelToRotate.quaternion.multiplyQuaternions(initialLensQuaternion, spinQuaternion);

                console.log('Current Lens Angle (Radians):', currentLensAngle.toFixed(4));
            }
        }
        previousMouseY = touch.clientY;
    }

    function onTouchEnd(event) {
        if (isDragging && currentFocusName === 'objLenses') {
            snapToNearestObjective();
        }
        isDragging = false;
    }

    function snapToNearestObjective() {
        isSnapping = true;
        let closestDifference = Infinity;
        
        // Count full turns
        const fullTurns = Math.floor(currentLensAngle / (Math.PI * 2));

        // Check target angles across all rotations to find ABSOLUTE closest point
        TARGET_LENS_ANGLES.forEach(targetAngleInTurn => {
            let fullTargetAngle = (fullTurns * Math.PI * 2) + targetAngleInTurn;
            let nextTargetAngle = ((fullTurns + 1) * Math.PI * 2) + targetAngleInTurn;
            let prevTargetAngle = ((fullTurns - 1) * Math.PI * 2) + targetAngleInTurn;

            // Compare against all three potential targets
            [fullTargetAngle, nextTargetAngle, prevTargetAngle].forEach(target => {
                const diff = Math.abs(target - currentLensAngle);
                if (diff < closestDifference) {
                    closestDifference = diff;
                    targetLensAngle = target;
                }
            });
        });
    }

    function zoomIn(modelName) {
        const modelData = INTEREST_POINTS[modelName];
        const partData = modelParts.find(p => p.name === modelName);
        if (!modelData || !partData) return;

        currentFocusName = modelName; // Set current focus
        isAnimating = true;
        targetCameraPosition.copy(modelData.cameraPos);
        targetCameraLookAt.copy(modelData.lookAt);
        controls.enabled = false;
        backButton.classList.remove('hidden');
        document.getElementById('info').innerText = `Now viewing: ${partData.friendlyName || modelName}`;

        // Outline Logic for ZoomIn
        // Only select meshes of currently focused object
        const focusedMeshes = allInteractiveMeshes.filter(mesh => 
            mesh.userData.interactiveName === currentFocusName
        );
        
        outlinePass.selectedObjects = focusedMeshes;
        outlinePass.edgeStrength = 5.0;
        outlinePass.visibleEdgeColor.set(0xffff00); 
    }

    function zoomOut() {
        currentFocusName = null; // Clear focus
        isAnimating = true;
        isDragging = false;
        isSnapping = false;
        targetCameraPosition.copy(homeCameraPosition);
        targetCameraLookAt.copy(homeCameraLookAt);
        controls.enabled = true;
        backButton.classList.add('hidden');
        document.getElementById('info').innerText = 'Click an interactive part to zoom in.';
        document.body.style.cursor = 'default';

        setInitialOutline(); // Return to faint outline for all interactive parts
    }

    // ANIMATION LOOP
    function animate() {
        requestAnimationFrame(animate);
        
        // Damping value - adjust to speed up movements
        const delta = 0.05;
        const snapSpeed = 0.1;

        if (isAnimating) {
            camera.position.lerp(targetCameraPosition, delta);
            controls.target.lerp(targetCameraLookAt, delta);

            const distance = camera.position.distanceTo(targetCameraPosition);
            if (distance < 0.01) {
                camera.position.copy(targetCameraPosition);
                controls.target.copy(targetCameraLookAt);
                isAnimating = false;
            }
        }

        if (isSnapping) {
            const diff = targetLensAngle - currentLensAngle;

            // Check if close enough to stop snapping
            if (Math.abs(diff) < 0.005) {
                currentLensAngle = targetLensAngle;
                isSnapping = false;
            } else {
                // Smoothly move current angle towards target angle
                currentLensAngle = THREE.MathUtils.lerp(currentLensAngle, targetLensAngle, snapSpeed);
                
                // Apply new rotation angle
                const modelToRotate = interactiveModels['objLenses'];
                if (modelToRotate) {
                    const spinQuaternion = new THREE.Quaternion().setFromAxisAngle(localLensRotationAxis, currentLensAngle);
                    // Combine initial tilt with interactive spin
                    modelToRotate.quaternion.multiplyQuaternions(initialLensQuaternion, spinQuaternion);
                }
            }
        }

        controls.update(); 
        composer.render();

        stats.update();
    }
    </script>
</body>
</html>